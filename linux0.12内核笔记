内核管理的16MB线性地址是一一对应到物理地址上的， 占用了4个目录项（目录项填的页表地址是物理地址）， 及4个页表。 一个任务是64MB，  占用16个目录项， 及16个页表。
tss, ldt存在内核代码中哪个地方？
答：内核的 struct task_struct中指定了tss和ldt。 在这个结构中还指定了执行文件的inode， 当前工作路径等信息。 甚至进程内核堆栈也是在此结构对应的page内。
set_base(p->ldt[1],new_code_base) 解释：
ldt是描述代码段，数据段地址起始地址及其他信息的表， set_base作用的是将代码基址记录在ldt中。可参考6.4.3.2int 32位保护运行机制中图6-12 linux内核使用描述符表的示意图

页目录和页表只是在你寻址的时候需要用到， 不能与new_code_base等概念混淆。

当需要拷贝代码时， 不会直接拷贝代码内容， 只是以拷贝页表共享代码物理内存的形式来拷贝代码内容。


copy_page_tables中unsigned long * from_dir, * to_dir中 to_dir表示的是目录表中目录项的地址， *to_dir指的是对应目录项的内容。 to_dir只有低12位有数字，其他都是0， 可为啥能表示目录表中目录项
的地址， 这是因为， 目录表位于整个物理内存的起始， 内核管理的线性地址一一对应到物理地址， 此时to_dir虽然说是线性地址，但实际上在内核里也是物理地址。 所以to_dir就表示了目录表的索引地址， *to_dir
也表示对应目录项的具体内容。


内核全局布局示意图，可查看5.8.1 初始化阶段章节。

bootsect.s 程序是磁盘引导块程序，编译后会驻留在磁盘的第一个扇区中（引导扇区， 0 磁道（柱
面）， 0 磁头，第 1 个扇区）。在 PC 机加电 ROM BIOS 自检后，将被 BIOS 加载到内存 0x7C00
处进行执行。
setup.s 程序主要用于读取机器的硬件配置参数，并把内核模块 system 移动到适当的内存位置处。
head.s 程序会被编译连接在 system 模块的最前部分，主要进行硬件设备的探测设置和内存管理
页面的初始设置工作。


控制器的作用：
  背景：之前一直不理解控制器啥作用， 比如键盘如果有中断响应，就发起中断，cpu接收键盘的数据不就可以了吗？ 非也。
  作用：当控制器对应的设备有数据来时， 需要将设备发来的数据缓存， 同时向cpu发送中断， cpu会根据中断优先级判断是否优先处理当前的中断， 一旦cpu接收当前中断， cpu就会触发对应的中断服务例程， 通过对应
控制器端口接收控制器接收到的缓存数据进行处理。
